---
title: Redis内存淘汰机制
date:  2021-04-12 21:56:37
toc: true
tags: 
- redis
- 2021
- redis 进阶
categories:
- 知识体系
---

原文：https://haicoder.net/note/redis-interview/redis-interview-redis-memory-eliminat.html

## 描述

**[Redis](https://haicoder.net/redis/redis-tutorial.html)** 的用途非常广泛。作为一个高性能的内存数据库，它经常被用于缓存的业务场景。所谓缓存，即在第一次获取到数据的时候，把它暂存在内存中。这样下次需要这个数据的时候，就直接从内存中取，不用再去查询数据库或调用远程接口，这样可以极大地提高应用程序的性能。

如果缓存中的数据永久存在，那占用的内存就会变得越来越大。而内存是有限的，所以缓存系统需要在需要的时候删除一些不必要的缓存数据以节约内存空间。Redis 提供了两种机制配合来达到上述目的：**[过期策略](https://haicoder.net/note/redis-interview/redis-interview-redis-expire.html)** 和内存淘汰机制。
<!-- more -->

## 过期策略

使用过 Redis 的同学应该知道，我们在设置一个 KEY 之后，可以指定这个 KEY 的过期时间。那么这个 KEY 到了过期时间就会立即被删除吗？Redis 是如何删除这些过期 KEY 的呢？

先说结论：Redis 是使用定期删除+惰性删除两者配合的过期策略。

### 定期删除

定期删除指的是 Redis 默认每隔 100ms 就随机抽取一些设置了过期时间的 KEY，检测这些 KEY 是否过期，如果过期了就将其删掉。因为 KEY 太多，如果全盘扫描所有的 KEY 会非常耗性能，所以是随机抽取一些 KEY 来删除。这样就有可能删除不完，需要惰性删除配合。

### 惰性删除

惰性删除不再是 Redis 去主动删除，而是在客户端要获取某个 KEY 的时候，Redis 会先去检测一下这个 KEY 是否已经过期，如果没有过期则返回给客户端，如果已经过期了，那么 Redis 会删除这个 KEY，不会返回给客户端。

所以惰性删除可以解决一些过期了，但没被定期删除随机抽取到的 KEY。但有些过期的 KEY 既没有被随机抽取，也没有被客户端访问，就会一直保留在数据库，占用内存，长期下去可能会导致内存耗尽。所以 Redis 提供了内存淘汰机制来解决这个问题。

为什么不使用定时删除？所谓定时删除，指的是用一个定时器来负责监视 KEY，当这个 KEY 过期就自动删除，虽然内存及时释放，但是十分消耗 CPU 资源，因此一般不推荐采用这一策略。

## 内存淘汰机制

Redis 在使用内存达到某个阈值（通过 maxmemory 配置)的时候，就会触发内存淘汰机制，选取一些 KEY 来删除。内存淘汰有许多策略，下面分别介绍这几种不同的策略。具体配置如下：

![06_Redis内存淘汰机制.png](https://wdj-1252419878.cos.ap-beijing.myqcloud.com/blog/2021-04-12-135154.png)

具体每一种策略解释如下：

| 名称            | 描述                                                   |
| --------------- | ------------------------------------------------------ |
| volatile-lru    | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰   |
| volatile-lfu    | 从已设置过期时间的数据集中挑选最不经常使用的数据淘汰   |
| volatile-ttl    | 从已设置过期时间的数据集中挑选将要过期的数据淘汰       |
| volatile-random | 从已设置过期时间的数据集中挑选任意数据淘汰             |
| allkeys-lru     | 当内存不足写入新数据时淘汰最近最少使用的KEY            |
| allkeys-random  | 当内存不足写入新数据时随机选择KEY淘汰                  |
| allkeys-lfu     | 当内存不足写入新数据时移除最不经常使用的KEY            |
| no-eviction     | 当内存不足写入新数据时，写入操作会报错，同时不删除数据 |

其中 no-eviction 是默认策略也就是当内存不足以容纳新写入数据时，新写入操作会报错。

如何选取合适的策略？比较推荐的是两种 lru 策略。根据自己的业务需求。如果你使用 Redis 只是作为缓存，不作为 DB 持久化，那推荐选择 allkeys-lru；如果你使用 Redis 同时用于缓存和数据持久化，那推荐选择 volatile-lru。

## 持久化与内存淘汰

### RDB

- 生成 rdb 文件：生成时，程序会对键进行检查，过期键不放入 rdb 文件。
- 载入 rdb 文件：载入时，如果以主服务器模式运行，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会忽略；如果以从服务器模式运行，无论键过期与否，均会载入数据库中，过期键会通过与主服务器同步而删除。

### AOF

- 当服务器以 aof 持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被删除，那么 aof 文件不会因为这个过期键而产生任何影响；当过期键被删除后，程序会向 aof 文件追加一条 del 命令来显式记录该键已被删除。
- aof 重写过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的 aof 文件中。

### 复制

当服务器运行在复制模式下时，从服务器的过期删除动作由主服务器控制：

- 主服务器在删除一个过期键后，会显式地向所有从服务器发送一个 del 命令，告知从服务器删除这个过期键;
- 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键;
- 从服务器只有在接到主服务器发来的 del 命令后，才会删除过期键。