---
layout: post
title: 运行时数据区域
---

Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄露和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会称为一项异常艰难的工作。

## 运行时数据区域
![1572756166174](/assets/images/1572756166174.png)
### 1. 程序计数器
程序计数器（Program Counter Register）：当前线程执行字节码的行号指示器。

字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，**分支、循环、跳转、异常处理、线程恢复**等基础功能都需要依赖这个计数器来完成。

Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，一个处理器内核在一个确定的时刻只会执行一条线程中的指令。因此各个线程都需要一个独立的程序计数器来保证线程切换后能恢复到正确的执行位置。

各线程之间计数器互不影响，独立存储。这类内存区域称为“线程私有”的内存。

线程执行的是一个Java方法，计数器记录的是 正在执行的虚拟机字节码指令的地址；
执行的是Native方法，这个计数器值为空。

此内存区域唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。

### 2. Java虚拟机栈
Java虚拟机栈（Java Virtual Mechine Stacks）也是线程私有的，生命周期与线程相同。虚拟机栈描述的是 **Java方法** 执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储 **局部变量表、操作数栈、动态链接、方法出口** 等信息。

**每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。**

网上常说的栈内存和堆内存，其中的栈内存其实对应着上面提到的 局部变量表的部分。

#### 局部变量表
存放了编译期可知的各种基本数据类型、对象引用和 returnAddress类型（指向了一条字节码指令的地址）。

64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型占一个。

局部变量表所需的内存空间在编译期间完成分配，进入一个方法时，这个方法需要在帧中分配的局部变量空间是完全确定的。=> **内存分配大小确定。**

局部变量表内容越多，栈帧越大，栈深度越小。
可通过 -Xss 参数控制

异常类型：
- 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常。
- 当动态拓展栈空间时，申请不到足够的内存，将抛出 OutOfMemoryError 异常。

### 3. 本地方法栈
Native Method Stack

本地方法栈与虚拟机栈作用相似，区别为：虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。

本地方法栈也会抛出 StackOverFlowError 和 OutOfMemoryError。

### 4. Java堆
Java Heap
Java堆是被所有线程共享的一块儿内存区域，在虚拟机启动时创建。

几乎所有的对象实例都在堆上分配内存。

随着JIT编译器的发展，在编译期间，如果JIT经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。但是这也并不是绝对的。就像我们前面看到的一样，在开启逃逸分析之后，也并不是所有User对象都没有在堆上分配。[摘自：对象并不一定都是在堆上分配内存的。
](https://blog.csdn.net/w372426096/article/details/80333657)

-XX:+DoEscapeAnalysis ： 表示开启逃逸分析

从jdk 1.7开始已经默认开始逃逸分析，如需关闭，需要指定-XX:-DoEscapeAnalysis

Java堆是垃圾收集器管理的主要区域。也被称为“GC堆”。

抛出异常：OutOfMemoryError

### 5. 方法区
Method Area

线程共享的内存区域

用于存储**已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码**等。也被称为 Non-Heap（非堆）。

#### 永久代

很多人更愿意把方法区称为“永久代（Permanent Generation）”，本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC的分代收集扩展至方法区，或者说**使用永久代来实现方法区**而已，这样HotSpot的垃圾收集器可以像管理java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。

动态生成类的情况比较容易出现永久代的内存溢出。最典型的场景就是，在 jsp 页面比较多的情况，容易出现永久代内存溢出。

jdk1.6常量池放在方法区，jdk1.7常量池放在堆内存，jdk1.8放在元空间里面，和堆相独立

抛出异常：当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。PermGen space

#### 元空间(Meta Space)

**元空间并不在虚拟机中，而是使用本地内存**

移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap。

JDK 1.8中 PermSize 和 MaxPermGen 已经无效。

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：

-XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。

-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。

元空间替换永久代原因:
- 字符串存在永久代中，容易出现性能问题和内存溢出。
- 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出。
- 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
- 为了HotSpot与JRockit的融合。

抛出异常：当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。MetaSpace

#### 运行时常量池
Runtime Constant Pool 

方法区的一部分。

Class文件信息包括：版本、字段、方法、接口、常量池（Constant Pool Table）。

常量池用于存放编译器生成的各种字面量和符号引用（以及直接引用）。这部分内容将在类加载后进入方法区的运行时常量池中存放。

- 符号引用：  符号引用以一组符号来描述所引用的目标，符号可以是任意形式的字面量，只要使用时能无歧义的定位到目标即可。符号与虚拟机实现的内存布局无关，引用目标并不一定加载到内存中（方法区）。包括三类: 1.类和接口的全限定名; 2.字段的名称和描述符; 3.方法的名称和描述符 
```java
 public static int iVal = new Random().nextInt();
```
- 直接引用: 直接引用可以**指向目标的指针**、**相对偏移量**或者是一个**能够直接定位到目标的句柄**。直接引用于虚拟机的内存布局相关，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不同。如果有了直接引用，那么，所引用的目标一定已经在内存中存在。
```java
    public static final String TEST_STR = "test";
```

JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，**运行时常量池也是每个类都有一个**。class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。

#### 全局字符串池（string pool也有叫做string literal pool）
全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。

#### 8种基本类型的包装类和常量池
java中基本类型的包装类的大部分都实现了常量池技术，
即Byte,Short,Integer,Long,Character,Boolean；

两种浮点数类型的包装类Float,Double并没有实现常量池技术。

(1)Integer i1=40；Java在编译的时候会直接将代码封装成Integer i1=Integer.valueOf(40);从而使用常量池中的对象。
(2)Integer i1 = new Integer(40);这种情况下会创建新的对象。

包装类进行运算会进行自动拆箱，比较时需要注意

![1572756188057](/assets/images/1572756188057.png)

### 直接内存（Direct Memory）
java虚拟机定义之外的频繁使用的内存区域。

JDK1.4中新加入的NIO（New Input/Output）类，引入了一种基于通道（channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java队中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。

服务器管理员在配置虚拟机参数时，会根据实际内存设置 -Xmx 等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态拓展时出现OutOfMemoryError异常。